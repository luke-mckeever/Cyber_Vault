# ü¶†Malware Analysis - Malicious Software Investigation Procedure

## Intro

> Malware analysis is the process of examining malicious software to understand its behavior, origin, and impact. 

N.B. Safety is the most important aspect, as improper handling can lead to infections or data breaches. 

It is crucial for identifying threats, developing defences, and improving incident response, helping cybersecurity professionals protect systems and data from attacks.

### ‚ö†Ô∏è Appropriate Malware Handling

The most vulnerable time during any malware analysis is when malware is in transit.
moving malware from one machine to another can be dangerous and may pose the risk of accidental detonation. 
There are a number of steps that can be taken to reduce this risk as prevention of not possible

1. Changing the File Type extension - changing a windows executable (.exe) to something inert like ".thisisnotmalware" can ensure that detonating this will not result in an infection
2. Ensure all malware samples are contained within an Archived Zipped file and also password protect these Zip File - (Standard Password: infected)

---

### Breakdown
Malware Analysis is Always broken down to the four main processes

- Basic Static Analysis 
	This involves investigating the statically available IOC‚Äôs of a malicious File 
	Such as: Strings, Dll‚Äôs, Libraries etc. 
- Basic Dynamic Analysis
	This involves detonating the malicious file to obtain the available IOC‚Äôs 
	Such as: Second Stage Payloads, Connections (Host based Indicators/Network Based Indicators)
- Advanced Static Analysis 
	This involves decompiling the malicious file to investigate the assembly.
- Advanced Dynamic Analysis 
	This involves running the malicious file through a debugger to investigate the potential anti-analysis nature of the file.

Static and dynamic malware analysis are two fundamental techniques used in cybersecurity to examine and understand the behaviour of malware. Here's a brief comparison of the two:

1. **Static Malware Analysis:**
- **Method:** Analyses the malware without executing it. This involves examining the code, binaries, and other static properties of the malware to understand its potential behaviour.
- **Tools:** Disassemblers (like IDA Pro), debuggers (like OllyDbg), and hexadecimal editors.
- **Advantages:** Safe as the malware does not run; can reveal malware intended to avoid detection when active; good for initial quick assessments.
- **Disadvantages:** Less effective against sophisticated malware that uses obfuscation and encryption to hide its true intent; cannot see runtime behaviours.

1. **Dynamic Malware Analysis:**  
- **Method:** Involves executing the malware in a controlled environment (often a virtual machine) to observe its behaviour during runtime.
- **Tools:** Sandboxes (like Cuckoo Sandbox), system monitoring tools (like Process Monitor), and network traffic analyzers (like Wireshark).
- **Advantages:** Can observe actual behaviour as it happens; effective in analysing polymorphic and encrypted malware; can capture system-level interactions and network traffic.
- **Disadvantages:** Riskier as it involves running the malware; sophisticated malware may detect the analysis environment and alter its behaviour.

---

## 1Ô∏è‚É£ Basic Static Analysis 

The process of basic static analysis does not include the detonation of the executable/malware as in the process of **Static** this involves analysing the file without detonation

### üß† Gathering Information
First steps when conducting **Static Analysis** is to gather the information surrounding the file itself such as:

SHA256 File Hash:
MD5 File Hash:
Original File Name:
Current File Name:
File Size:
File Type: 

We can use the following command to assist in extracting the file hash:
```powershell
get-filehash <INSERT FILE NAME> -alg sha256sum
```
^ This will extract the SHA256 hash value of the given file

```powershell
get-filehash <INSERT FILE NAME> -alg md5sum
```
^ This will extract the MD5 hash value of a given file

The above commands are relative to the PowerShell command line alternative methods are utilised with processes such as CMD.

### üîçPerforming Open Source Intelligence (OSINT) 

Whenever possible, it‚Äôs easier to obtain information from existing file analysis services than to manually perform the lengthy process of malware analysis. 
Many providers already host and analyze previously submitted files.

Here are some great sources of Malware Analysis Intelligence Providers:
- **[VirusTotal](https://www.virustotal.com/)** - Aggregates results from 70+ AV engines, sandboxes, and threat intel feeds. ¬†
- **[Hybrid Analysis](https://www.hybrid-analysis.com/)** -¬†Free sandbox analysis by CrowdStrike Falcon Sandbox; great for dynamic behavior reports. ¬†
- **[Joe Sandbox](https://www.joesandbox.com/)** - Advanced multi-platform sandboxing with in-depth static and dynamic analysis. ¬†
- **[ANY.RUN](https://any.run/)** - Interactive malware sandbox for dynamic analysis; allows manual control during execution. ¬†
- **[MalwareBazaar](https://bazaar.abuse.ch/)** - Threat intel repository by Abuse.ch for downloading and researching malware samples

This will provide a high level overview of the executable and or if it has ever been seen previously.
See the Image below if an example malicious file:
![[Pasted image 20250318071614.png]]

> ‚ö†Ô∏è Please exercise caution when uploading files to these sites as the results are publicly visible!  

### ü™¢Identifying strings within malware 

what are strings? - Within programming strings are just a bunch of characters that together make up a word.
In the context of malware analysis, these strings may be a domain, an IP, etc. 

In turn these strings have been embedded into the executable and can be easily analysed if not properly obfuscated. 
These strings may include information used to exfiltrate data or download a second stage payload.

 To extract these **Strings** from an executable we can utilise many tools to assist, one common one is FLOSS.
 
 Which can be utilised as below
```bash
floss <INSERT FILE NAME>
```
^ This will present a dump of all identified strings greater than four characters

Comparing these Strings to other indicator identified throughout the investigation may prove to be crucial for identifying hardcoded indicators (which isn't always the case)

### Breaking down the structure of an executable 

This poses the question, what does an executable or a portable executable look like, 
we know what a text file or a power shell script look like but what is an executable .

In simple terms it is a compiled bunch of bytes, and breaking this down may reveal some information crucial to an investigation.
To break down an executable we can use a tool called **PEview**. 

`PEview` is a tool used primarily in Windows environments to examine the details of Portable Executable (PE) files. These files include executable (.exe), dynamic link libraries (.dll), and other file types used by the Windows operating system.
In the context of malware analysis, tools like PEview are used in static analysis to quickly assess the composition and potential capabilities of a suspicious file without executing it. By examining the PE structure, analysts can identify signs of malware, such as unusual sections, unexpected imports, or exports, and other indicators of compromise.

To use [[PEview]] we can download it from [HERE](http://wjradburn.com/software/PEview.zip)
This is a Graphical Tool and not Command line based (which we love) so upon running this tool it will immediately ask you for an executable to examine.

Select which PE to exam and it will immediately load the structure of the binary.
On the right hand side column you will see the binary byte array for the executable, this is literally the PE in it's entirety 
On the left hand side is a handy reference to the different headers that make up the binary 

Headers to Note:
IMAGE_NT_HEADERS > IMAGE_FILE_HEADER > Time Date Stamp   -  This is the time stamp of the initial compile of the code to executable format (N.B this can be illegitimate caution is advised)
IMAGE_SECTION_HEADER .text -  Comparing the virtual size of the binary and the raw size of the binary is a good way to tell if this is a **Packed** binary (This will need converted from HEX)
SECTION .rdata > IMPORT Address Table - This is the Import Address Table, also known as the Windows API Calls table, this will list all windows API calls
	A Great resource to identify malicious API calls is [MalAPI.io](https://MalAPI.io) an online catalogue of Windows APIs that are commonly used in malware

> A packed binary refers to an executable file that has been compressed or encrypted using a technique known as "packing." This is commonly done to reduce the file size or protect the executable from being easily analysed or reverse-engineered

> A Custom made Cheat Sheet of API calls is also available HERE -> [[Windows API Calls]]

#### üì¶Packed vs Unpacked Malware:
**Unpacked Malware:** This type of malware is in its original form, making it easier for security software to analyse and detect because all its components are visible and straightforward.
**Packed Malware:** Packed malware has been modified using a tool that compresses or encrypts its contents to hide its true nature. This makes it difficult for antivirus programs to detect it directly because the malicious code is concealed.

**How Malware Gets Packed:**
1. **Choosing a Tool:** Malware creators pick a tool that can compress or encrypt the malware effectively.
2. **Packing the Malware:** They run the malware through this tool, which scrambles the data, making it look harmless or confusing to security systems.
3. **Executing the Malware:** The packed malware includes a small piece of code that, when run, unpacks the malware in the computer's memory, allowing it to carry out its harmful activities without ever showing the original malicious code on the hard drive.

In essence, packed malware is tougher to spot and analyse because it‚Äôs disguised, whereas unpacked malware is more straightforward and easier to handle for security systems.

#### Combination Analysis

The Amazing tool known as [[PEstudio]] is great for basic static analysis as it combines the majority of tools previously referenced,
The tool is able to gather the following information: (Hash values, File type, Compiler timestamp, Indicators, and many more)

Within the indicators section PEstudio is able to evaluate the byte array and strings to extract information that aligns with known attacker indicators, such as malicious API calls or URL references
Within the libraries section of PEstudio this is able to list out the dynamic link libraries utilised in the executable

Another Great tool to give a high level overview, entropy results, Strings and more is [[Detect It Easy (DIE)]]
This tool is great for basic static analysis.

Another Great utility for a general overview of an executable is **[[CAPA]]**
Capa is a tool used in the field of malware analysis and reverse engineering, designed to help security professionals automatically identify the capabilities of executable files. Developed by Mandiant, CAPA operates by inspecting binary files (such as those ending in .exe or .dll) to discover and classify a wide range of features and behaviours that are often seen in malicious software.

To use Capa we can use the following command:
```bash
capa <INSERT FILE NAME>
```

This will present the following output example
![[Pasted image 20250318144758.png]]

---

## 2Ô∏è‚É£ Basic Dynamic Analysis

Basic dynamic analysis is the process of examining executable files or malware by running them in a controlled environment to observe their behaviours and interactions with the system and network.

Dynamic malware analysis can be broken down into two primary components based on the types of data collected during the analysis: host-based indicators and network-based indicators. Here‚Äôs how each plays a crucial role in understanding and identifying malware activities:

1. **Host-Based Indicators:** - These are the signs and signals of malicious activity that can be observed on the computer where the malware is executed. Host-based indicators provide insights into how the malware interacts with the system‚Äôs files, registry, processes, and other critical components.
 **Examples:** File Modifications, Registry Changes, Process Behaviour, System Logs, Memory Anomalies
 
2. **Network-Based Indicators:** - These indicators capture the interactions between the malware and network resources, revealing how the malware communicates, propagates, or exfiltrates data.
**Examples:** Network Traffic, DNS Requests, HTTP Requests, Port Activity

#### üß™The Setup 

When preforming Dynamic Analysis of an executable it is important to ensure your tooling is established and ready to analyse the malware 
In some cases malware may attempt to delete itself, if this is the case we require active tools to detect why this was the case and later attempt to debug it.

#### üõúNetwork Based Indicators

When detonating a malware sample or executable it is common for the malware to reach out to an external domain, this may be for a number of reasons
- Second Stage Payload
- Exfiltration of Data
- etc
A Great tool for detecting these network requests is [[Wireshark]], as it can identify the application that issued the request, and later we can add these requests to an IPS or create YARA rules 

#### üíªHost Based Indicators

When detonating a malware sample or executable it is common for the malware to create sub-processes that carry out specific functions for the malware 
A great tool for detecting these processes is **[[Procmon]]** a.k.a. Process Monitor, this will be able to show the analyst which processes spawned as a result of execution

When using this tool, it is recommended to filter by the processes name, this will assist in identifying exactly what the process spawns upon execution 
This will also ensure no other Windows processes are mixed in with the ones spawned.

Just Like many EDR/XDR solutions Procmon also has the utility to graphically map parent - child process relationships, utilising the Process Tree section of the application
This will allow the analyst to identify any spawned processes from the initial execution of the sample.
This can also assist with identifying the Process ID of the malware in order to filter by this to see other processes spawned 

##### üîÑIdentifying Reverse/Bind Shells

One of the most common types of malware is a RAT or remote access trojan, in this instance a shell is spawned on the victims machine which allows for command injection by the attacker. many techniques are deployed for this to be successful and in some instances these RAT's are established as persistent either in the the victims auto-runs or start-up directory.

To identify these shells we can use tools like [[TCP view]] to assist in identifying connection spawned on suspicious ports by the parent malicious executable.
Another tool that can assist with identifying these connection is Procmon, and can essentially do the same thing as TCPview

If it is the case where we can identify that a sample is preforming a DNS query to initialise a connection to a potential C2 but as we are in a segmented environment this connection will never occur especially because it is done so utilising DNS quires, we can do some trickery and spoof the malware into thinking the domain it is querying is actually the host that it is on (Teehee). this DNS request can be obtained from tools such as Wireshark

How to spoof the etc/hosts file for malicious DNS queries:
Built into Cmder is the Nano text editor, we can use this to edit the hosts file on the Flare VM host using the following command:

```sh
nano C:\Windows\System32\drivers\etc\hosts
```

The cool thing about our Flare VM is that it has the best of both Windows and Linux (intentionally) so the hosts file can be edited to contain domain names and have them associated with IP addresses.

To associate a domain with the host VM we can input the following into the hosts file:

```text
127.0.0.1 <NAME OF MALICIOUS DNS QUERY DOMAIN>
```
^ CTRL + O (to write to the file), Enter (to confirm), CTRL + X (to save and exit the editor)

To further identify the meaning behind this DNS request we can use tools such as Procmon

---

## 3Ô∏è‚É£ Advanced Static Analysis

The first stage of advanced static analysis is being able to understand the binary in a low level
This means converting the many many bits ("1's" and "0's") that make up such an executable / application

To convert these so called bit's into readable format we can use a tools known as [Cutter](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Cutter.md)
This tool will decompile the binary that we would like to investigate, this will then convert the binary into a language known as assembly [[Cutter]]

> Assembly is a low-level programming language that provides a direct way to write instructions for a computer's CPU. It's closely tied to the hardware and is specific to each processor architecture.

A full breakdown of how to use cutter is located in the tools section of this repo - [HERE](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Cutter.md)

#### Understanding Assembly Registers 

###### CPU Instructions

|**Operation**|**Destination**|**Source**|                                  **Description**                                      |
|-------------|---------------|----------|---------------------------------------------------------------------------------------|
|    `mov`    |     `edx`     |   `eax`  |                       Copies the value in `eax` into `edx`                            |
|    `jmp`    |     `edx`     |     -    |               Jumps to the address stored in `edx`. `eax` is not used                 |
|    `sub`    |     `edx`     |   `eax`  |           Subtracts the value in `eax` from `edx`, result stored in `edx`             |
|    `push`   |       -       |   `edx`  |           Pushes the value in `edx` onto the stack. `eax` is not involved             |
|    `pop`    |     `edx`     |     -    |         Pops the top value from the stack into `edx`. `eax` is not involved           |
|    `call`   |     `edx`     |     -    | Calls the procedure at the address in `edx`; pushes return address onto the stack     |
|    `ret`    |       -       |     -    | Returns from procedure by popping the return address from the stack and jumping to it |

###### Memory Registers
**Instruction Pointer (IP):**  
The Instruction Pointer is a register in the CPU that keeps track of the address of the next instruction to run. It's also called the **Program Counter**.
- In early Intel 8086 processors (16-bit), it was called **IP**.
- In 32-bit systems, it became **EIP** (Extended Instruction Pointer).
- In 64-bit systems, it‚Äôs known as **RIP** (Register Instruction Pointer).

The above is same for the below General-Purpose Registers:

- **`eax` or `rax` ** ‚Äì **Accumulator Register**: Used for arithmetic operations and storing return values from functions.
- **`edx` or `rdx`** ‚Äì **Data Register**: Often used in input/output operations and as an extension of `eax` in multiplication/division.
- **`ebx` or `rbx`** ‚Äì **Base Register**: Can be used to store base addresses for data access.
- **`ecx` or `rcx`** ‚Äì **Counter Register**: used in counting operations such as loops, etc.
- **`esp` or `rsp`** ‚Äì **Stack Pointer**: Points to the top of the current stack frame; used to manage function calls and local variables.
- **`ebp` or `rbp`** ‚Äì **Base Pointer**: Points to the base of the current stack frame; used to access function parameters and local variables.
- **`eip` or `rip`** ‚Äì **Instruction Pointer**: Holds the address of the next instruction to execute.
- **`esi` or `rsi`** ‚Äì **Source Index Register**: used for string operations. It is used with the Data Segment (DS) register as an offset.
- **`edi` or `rdi`** ‚Äì **Destination Index Register**: used for string operations. It is used with the Extra Segment (ES) register as an offset
-  **`R8-R15`** ‚Äì not present in 32-bit systems. (**R8D** (lower 32 bits), **R8W** (lower 16 bits), **R8B** (lower 8 bits), etc.)

**Zero Flag:**
Denoted by ZF, the Zero Flag indicates when the result of the last executed instruction was zero. For example, if an instruction is executed that subtracts a RAX from itself, the result will be 0. In this situation, the ZF will be set to 1.

**Sign Flag:**
The Sign Flag or SF indicates if the result of an operation is negative or the most significant bit is set to 1. If these conditions are met, the SF is set to 1; otherwise, it is set to 0.

**Trap Flag:**
The Trap Flag or TF indicates if the processor is in debugging mode. When the TF is set, the CPU will execute one instruction at a time for debugging purposes. This can be used by malware to identify if they are being run in a debugger.

###### Segment Registers:
Segment Registers are 16-bit registers that convert the flat memory space into different segments for easier addressing. There are six segment registers, as explained below:
**Code Segment:**¬†The Code Segment (CS ) register points to the Code section in the memory.
**Data Segment:** The Data Segment (DS) register points to the program's data section in the memory.
**Stack Segment:** The Stack Segment (SS) register points to the program's Stack in the memory.
**Extra Segments (ES, FS, and GS):** These extra segment registers point to different data sections. These and the DS register divide the program's memory into four distinct data sections.


|  **General Registers**  |  **Segment Registers **  |  **Status Registers**  |  **Instruction Pointer**  |
| ----------------------- | ------------------------ | ---------------------- | ------------------------- |
|  RAX, EAX, AX, AH, AL   |            CS            |          EFLAGS        |         EIP, RIP          |
|  RBX, EBX, BX, BH, BL   |            SS            |                        |                           |
|  RCX, ECX, CX, CH, CL   |            DS            |                        |                           |
|  RDX, EDX, DX, DH, DL   |            ES            |                        |                           |
|  RBP, EBP, BP           |            FS            |                        |                           |
|  RSP, ESP, SP           |            GS            |                        |                           |
|  RSI, ESI, SI           |                          |                        |                           |
|  RDI, EDI, DI           |                          |                        |                           |
|  R8-R15                 |                          |                        |                           |


##### Format of an Assembly API call
Assembly API calls are made using  the specific syntax accredited to them per Microsoft official documentation or their structured syntax 
This will look something like the following

```asm
0x004010e3    push    0                                      //pushing the integer value of 0 to the stack
0x004010e4    push    0                                      //pushing the integer value of 0 to the stack
0x004010e9    push    0                                      //pushing the integer value of 0 to the stack
0x004010ea    push    0                                      //pushing the integer value of 0 to the stack
0x004010eb    push    str.<some string> ; 0x00403387         //pushing the sting of <some string> to the stack
0x004010ec    call    dword [<name of api>] ; 0x00403388     //preforming the api call of <name of api> from the stack 
```

> The above assembly language can be used to populate the memory stack with the pre-selected variables and preform the API call  

##### Classic Function Call (Initialisation of main)

```asm
int main (int argc, char **argv, char **envp)     //initialise with preset variables (comminly not utilised)
0x00401530      push     ebp                      //push ebp: preserves the calling function base address
0x00401531      mov      ebp, esp                 //mov ebp, esp: move the stack pointer value into the base pointer
0x00401533      and      esp, 0xffffffff0         //and esp, 0xffffffff0: verify stack
0x00401536      sub      esp, 0x10                //sub esp, 0x10: subtrack 16 from the stack, creating room for 16 pointers
0x00401539      call     dbg.__main               //call dbg.__main: main call of function
```

--- 

## 4Ô∏è‚É£ Advanced Dynamic Analysis

Advanced Dynamic Analysis involves executing (or detonating) a suspicious file in a controlled environment, similar to basic dynamic analysis, to observe its behavior in real-time. However, this approach goes further by incorporating debugging techniques to gain deeper insights into the malware‚Äôs inner workings.

Using tools such as x64dbg, OllyDbg, or WinDbg, analysts can interact with the malware at the instruction level, allowing them to:

- Set breakpoints and step through code
- Monitor memory modifications
- Observe function calls and API usage
- Bypass anti-analysis techniques (e.g. unpacking routines, environment checks)  

This method is crucial for uncovering obfuscated logic, hidden payloads, or conditional execution paths that wouldn‚Äôt be visible through automated dynamic analysis alone. It enables analysts to reverse engineer the malware‚Äôs functionality, persistence mechanisms, C2 infrastructure, and more.

### üêûDebugging 

> The main aspect of this process allows the analyst to step through potential malicious code and executables as to manually detonate assemble instructions one after another.

> The purpose of this is to identify where instructions are being executed, how they are being executed and most importantly when they are being executed as this will allow for the demonstration of function calls.

> A debugger will also allow and assist in memory analysis and during the step-through of the assembly the contents of the memory stark are present and visible for inspection. A debugger will also support the export of memory dump files at any stage of the assembly‚Äôs detonation. 

> Lastly the entire purpose of a debugger (compared to a decompiler) is to be able to set breakpoints.  Breakpoints allow for the manual stoppage of the assembly instruction.

[[x32dbg & x64dbg]] are open-source, user-friendly debuggers designed for analyzing 32-bit and 64-bit executables, respectively. They provide a powerful interface for reverse engineers and malware analysts to interact with binary files at the instruction level.

##### Cheat Sheet - Quick reference guide for keyboard shortcuts ¬ß

|   **Shortcut**    |          **Details**           |
| ----------------  |  ----------------------------  |
|        F9         |  Run/Continue execution        |
|        F8         |  Step Over                     |
|        F7         |  Step Into                     |
|        F4         |  Run Until Selection           |
|        F2         |  Toggle Breakpoint             |
|     Shift+F7      |  Step Into (Skip System Code)  |    
|     Ctrl+F7       |  Step Out (Run Until Return )  | 
|     Ctrl+F2       |  Restart Debugging             | 

#### ‚õìÔ∏è‚Äçüí•Breakpoints 

A **breakpoint** is a marker you set in a debugger (like **x64dbg, OllyDbg, WinDbg, or Cutter**) that tells the program to **pause execution** when it reaches a certain instruction.  

Think of it like putting a ‚Äústop sign‚Äù in the malware‚Äôs code so you can carefully examine what it‚Äôs doing **before it continues running**.

##### üõ† Types of Breakpoints
1. **Software Breakpoints (`INT 3`)**
   - Inserted into the code (e.g., at an API call like `WriteProcessMemory`).
   - Most common for malware debugging.

2. **Hardware Breakpoints**
   - Set on memory reads/writes or execution of an instruction.
   - Useful when you **can‚Äôt modify the code** (e.g., malware checksums itself).

3. **Conditional Breakpoints**
   - Only trigger if certain conditions are true (e.g., when a register equals a specific value).
   - Great for skipping unnecessary code loops.

##### üéØ Why Breakpoints Are Critical in Malware Analysis
- **Catch API Calls**: Stop at functions like  
  - `VirtualAllocEx` ‚Üí to see memory allocation for shellcode  
  - `WriteProcessMemory` ‚Üí to inspect injected payload  
  - `CreateRemoteThread` ‚Üí to analyze execution in another process  
- **Prevent Damage**: Pause before destructive functions like `DeleteFile`, `CryptEncrypt`, or registry modifications.
- **Unpack Malware**: Break just before or after the unpacking routine to extract the decrypted payload.
- **Study Control Flow**: Follow jumps, loops, or obfuscated logic in a controlled way.

##### ‚öôÔ∏è How to Use Breakpoints Efficiently
1. **Target High-Value API Calls**
   - Set breakpoints on imports often abused by malware:
     - `OpenProcess`, `VirtualAllocEx`, `WriteProcessMemory`, `CreateRemoteThread`
     - `GetProcAddress`, `LoadLibrary` (API resolution)
     - `WinExec`, `ShellExecuteA`, `CreateFileA/W`, `RegSetValueExA`

2. **Use Breakpoints as Safety Nets**
   - Place them **before potentially harmful actions** so you can intercept and examine before the system is affected.

3. **Leverage Hardware Breakpoints**
   - For packed or self-modifying malware, use hardware breakpoints on memory regions to catch when unpacked code gets executed.

4. **Step Around Loops**
   - Don‚Äôt waste time stepping through thousands of NOPs or junk instructions ‚Äî use conditional breakpoints or **step over** to save time.

5. **Combine With Logging**
   - In x64dbg, you can attach a log message to a breakpoint (e.g., ‚ÄúCreateRemoteThread called!‚Äù) without always halting execution.

#### üö® Example in Malware Debugging
Imagine you‚Äôre analyzing malware that injects shellcode into `explorer.exe`:

- **Breakpoint 1:** Set on `OpenProcess` ‚Üí identify the target PID.  
- **Breakpoint 2:** Set on `VirtualAllocEx` ‚Üí grab the memory address allocated in the target.  
- **Breakpoint 3:** Set on `WriteProcessMemory` ‚Üí dump the shellcode being injected.  
- **Breakpoint 4:** Set on `CreateRemoteThread` ‚Üí control when the malicious code starts executing.  

By using these breakpoints, you intercept the full injection chain without letting the malware fully execute and damage your system.

> For full list of API Calls which are beneficial for inserting breakpoints and can suggest malicious intentions see [[Windows API Calls]]

---

## üí°Specialty Malware Analysis

### MalDoc Analysis

**Summary:** Identify and dissect malicious Microsoft Office documents that may contain macros, embedded scripts, or exploits.  
**How To (Detailed):**

1. **Initial Inspection:**
    - Check the file extension (e.g., `.doc`, `.docm`, `.xls`, `.ppt`).
    - Run `file` or `trid` to confirm actual file type.
    - Use `oleid` to detect potential risks like macros, encryption, or suspicious streams.
2. **Macro Extraction:**
    - Run `olevba <file>` to extract and view VBA macros.
    - If obfuscated, use `oledump.py -s <stream#> -v <file>` to dump macro code.
    - Deobfuscate strings or code using regex searches, CyberChef, or Python scripts.
3. **Behavioral Testing:**
    - Execute the sample in a sandbox (e.g., `REMnux`, `Flare VM`, or a Windows VM with monitoring tools).
    - Capture network traffic with `Wireshark` and monitor system changes with `Procmon` or `Sysmon`.
4. **Indicators Collection:**
    - Extract IOCs such as URLs, IPs, domains, and dropped files.
    - Store findings in a structured log for reporting.

### PDF Analysis

**Summary:** Examine PDFs for hidden JavaScript, embedded files, or exploits targeting PDF readers.  
**How To (Detailed):**

1. **File Verification:**
    - Confirm file type with `file <sample.pdf>`.
    - Use `pdfid.py <sample.pdf>` to detect suspicious keywords (e.g., `/JavaScript`, `/OpenAction`, `/Launch`).
2. **Object Extraction:**
    - Parse with `pdf-parser.py <sample.pdf>`.
    - Extract and review suspicious objects (e.g., object streams containing JavaScript).
    - Decode encoded streams using built-in flags or export for manual analysis.
3. **Embedded Content Analysis:**
    - Look for embedded files, images, or executables.
    - Dump suspicious objects and analyze them separately.
4. **Dynamic Testing:**
    - Open the PDF in a controlled VM with logging tools.
    - Capture any spawned processes, network connections, or dropped files.

### Malicious Images

**Summary:** Investigate images that may hide payloads via steganography or malformed file structures.  
**How To (Detailed):**

1. **Header & Metadata Inspection:**
    - Open the image in a hex editor to check for abnormal headers or appended data.
    - Use `exiftool <image>` to review metadata for anomalies or hidden fields.
2. **Structural Validation:**
    - Confirm file integrity with tools like `binwalk` to detect embedded files or archives.
    - Compare reported file size vs. expected content size.
3. **Steganography Detection:**
    - Use `steghide extract -sf <image>` (if password known, try dictionary attack).
    - Run `zsteg <image.png>` for PNG-specific stego detection.
    - Cross-check with online steganalysis tools.
4. **Execution Safety Check:**
    - Test rendering the image in an isolated VM.
    - Watch for crashes or suspicious memory usage (could indicate malformed exploit payloads).
5. **IOC Extraction:**
    - Record hashes, extracted hidden content, and any embedded executables.
    - Add findings to a central analysis log.



--- 

## Creating Detection Logic for Malware Families 



---

## Malware Analysis Report Writing:


---











---

### Resources
List of other beneficial Knowledge Articles: 
- [Malware Types](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/Malware%20Types.md)
- [Malware Analysis Framework](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/Malware%20Analysis%20Framework.md)
- [MITRE ATT&CK Framework](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/MITRE%20ATT%26CK%20Framework.md)
- [Flare VM - Malware Lab Provisioning](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/Flare%20VM%20-%20Malware%20Lab%20Provisioning.md)
- [A Programs Perspective of Memory](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/A%20Program%E2%80%99s%20Perspective%20of%20Memory.md)
- [Email Attachment Analysis](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Knowledge%20Articles/All%20Knowledge%20Articles/Email%20Attachment%20Analysis.md)

List of other beneficial Cheat Sheets:
- [Magic Bytes](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Cheat%20Sheets/All%20Cheetsheets/Magic%20Bytes.md)
- [URL Encoding](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Cheat%20Sheets/All%20Cheetsheets/URL%20Encoding.md)
- [Ports & Protocols](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Cheat%20Sheets/All%20Cheetsheets/Ports%20%26%20Protocols.md)
-[Useful (Cyber) Domains](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Cheat%20Sheets/All%20Cheetsheets/Useful%20(Cyber)%20Domains.md)
- [Windows API Calls](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Cheat%20Sheets/All%20Cheetsheets/Windows%20API%20Calls.md)

#### Tools
- [Virus Total](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Virus%20Total.md)
- [Floss](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Floss.md)
- [PEview](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/PEview.md)
- [PEstudio](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/PEstudio.md)
- [Detect It Easy (DIE)](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Detect%20It%20Easy%20(DIE).md)
- [CAPA](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/CAPA.md)
- [Wireshark](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Wireshark.md)
- [Procmon](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Procmon.md)
- [TCP view](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/TCP%20view.md)
- [Cutter](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/Cutter.md)
- [x32dbg & x64dbg](https://github.com/luke-mckeever/Cyber_Vault/blob/main/Tooling/Blue%20Team%20Tools/x32dbg%20%26%20x64dbg.md)

#### Other great resources
- PMAT - Labs Malware Samples - Available [Here](https://github.com/HuskyHacks/PMAT-labs/tree/main/labs) 
- Malware Zoo - Live Malware samples - Available [HERE](https://github.com/ytisf/theZoo)  
- Malware Bazaar - Largest Malware sample database - Available [HERE](https://bazaar.abuse.ch/browse/)
- VX Underground - Complete sample and research malware site - Available [HERE](https://vx-underground.org/)
	- Their Git Hub is also available [HERE](https://github.com/vxunderground)